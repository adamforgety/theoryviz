<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TheoryViz</title>
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#3b82f6">
    <!-- The manifest link will be dynamically created by JS later -->

    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the SVG keyboard container */
        .keyboard-container {
            position: relative;
            height: 220px;
            margin-top: 20px;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            /* Light gray for contrast against the white keys */
            background-color: #f3f4f6;
            overflow-x: scroll; /* Allows the full keyboard width to be viewed */
            overscroll-behavior: contain; /* Prevents unwanted browser scroll on mobile drag */
        }

        /* Highlighting Styles for a consistent look with the buttons */
        .highlight-transition {
            transition: fill 0.2s ease;
        }

        /* Hide scrollbar for a cleaner look, while still allowing scroll */
        .keyboard-container::-webkit-scrollbar {
            display: none;
        }
        .keyboard-container {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

    </style>
</head>
<body class="bg-gray-50 font-sans p-4 md:p-8">

    <div class="max-w-4xl mx-auto bg-white rounded-xl shadow-2xl p-6 md:p-10">
        <h1 class="text-3xl md:text-4xl font-extrabold text-gray-800 mb-6 text-center">
            TheoryViz
        </h1>
        <p class="text-center text-gray-600 mb-8">
            Visualize harmony on your phone or tablet.
        </p>

        <!-- Control Panel -->
        <div class="flex flex-col md:flex-row justify-between items-center space-y-4 md:space-y-0 md:space-x-4 mb-8 p-4 bg-gray-100 rounded-lg">
            
            <!-- Key Selection -->
            <div class="w-full md:w-1/3">
                <label for="key-select" class="block text-sm font-medium text-gray-700 mb-1">Root Key</label>
                <select id="key-select" onchange="handleKeyChange(event.target.value)"
                        class="w-full p-3 border border-gray-300 rounded-lg bg-white text-gray-800 focus:ring-blue-500 focus:border-blue-500 shadow-sm transition">
                    <!-- Options populated by JS -->
                </select>
            </div>

            <!-- Centering Toggle -->
            <div class="w-full md:w-1/3">
                <label class="block text-sm font-medium text-gray-700 mb-1">Keyboard Scroll</label>
                <div class="flex items-center justify-between p-3 bg-white border border-gray-300 rounded-lg shadow-sm">
                    <span class="text-sm font-medium text-gray-600 select-none">Fixed</span>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="centering-toggle" class="sr-only peer" checked onchange="toggleCentering(event.target.checked)">
                        <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                    </label>
                    <span class="text-sm font-medium text-blue-600 select-none">Centering</span>
                </div>
            </div>

            <!-- Mode Selection -->
            <div class="w-full md:w-1/3">
                <label class="block text-sm font-medium text-gray-700 mb-1">Scale Mode</label>
                <div class="flex space-x-2">
                    <button id="major-mode-btn" onclick="handleModeChange(true)"
                            class="flex-1 py-3 px-4 rounded-lg font-bold transition duration-200 shadow-md">
                        Major
                    </button>
                    <button id="minor-mode-btn" onclick="handleModeChange(false)"
                            class="flex-1 py-3 px-4 rounded-lg font-bold transition duration-200 shadow-md">
                        Minor
                    </button>
                </div>
            </div>
        </div>

        <!-- Piano Keyboard (Now using SVG) -->
        <div id="piano-container" class="keyboard-container overflow-x-scroll pb-4">
            <svg id="piano-keyboard-svg" width="100%" height="200" preserveAspectRatio="xMinYMin slice"></svg>
        </div>
        
        <!-- Current Chord Name Display -->
        <div class="mt-6 mb-4 text-center">
            <p class="text-xl font-semibold text-gray-700">Current Chord:</p>
            <h2 id="current-chord-display" class="text-4xl font-extrabold text-blue-600 mt-1">
                <!-- Chord name will be displayed here -->
            </h2>
        </div>

        <!-- Chord Buttons -->
        <div id="chord-buttons-container" class="mt-8 grid grid-cols-4 sm:grid-cols-7 gap-3">
            <!-- Buttons will be dynamically generated here -->
        </div>
    </div>

    <script>
        // --- CONSTANTS AND MAPPING ---
        const KEYS = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const MAJOR_INTERVALS = [0, 2, 4, 5, 7, 9, 11];
        const MINOR_INTERVALS = [0, 2, 3, 5, 7, 8, 10];
        
        // Roman Numerals and Qualities (1-based index)
        const MAJOR_QUALITIES = ["I", "ii", "iii", "IV", "V", "vi", "vii째"];
        const MINOR_QUALITIES = ["i", "ii째", "III", "iv", "v", "VI", "VII"];

        // MIDI note range for the visual keyboard: C4 (60) to F6 (89) -> 30 keys (3 octaves)
        const START_MIDI = 60; // C4 (Middle C)
        const END_MIDI = 89;   // F6
        
        // --- SVG KEYBOARD CONFIGURATION (Adapted from the example) ---
        const KEYBOARD_CONFIG = {
            TOTAL_KEYS_RANGE: END_MIDI - START_MIDI + 1, // 30 keys
            WHITE_KEYS_COUNT: 18,
            
            // Virtual width for the SVG canvas 
            KEYBOARD_WIDTH: 1080,
            KEYBOARD_HEIGHT: 200,
            KEY_Y_START: 10,
            
            WHITE_KEY_HEIGHT: 180,
            WHITE_KEY_WIDTH: 1080 / 18, // 60
            
            BLACK_KEY_HEIGHT: 110,
            BLACK_KEY_WIDTH: (1080 / 18) * 0.6, // 36
        };

        const KEY_COLORS = {
            WHITE: '#ffffff',
            BLACK: '#1f2937',
            // Blue colors
            HIGHLIGHT_WHITE: '#3b82f6',
            HIGHLIGHT_BLACK: '#2563eb'
        };
        
        // Piano Key Structure (for lookup only, not for drawing structure)
        const PIANO_KEY_DATA = [];
        for (let i = START_MIDI; i <= END_MIDI; i++) {
            PIANO_KEY_DATA.push({
                midi: i,
                pitchClass: i % 12,
                name: KEYS[i % 12],
                isWhite: MAJOR_INTERVALS.includes(i % 12),
            });
        }

        // --- STATE ---
        let state = {
            currentKeyIndex: 0, // C is default
            isMajor: true,
            currentDegree: 1, // I or i
            triadPitchClasses: [], // Array of 3 pitch classes (0-11)
            triadMidiNotes: [], // Array of 3 specific MIDI notes
            isCenteringEnabled: true, // Default to centering for mobile
        };

        // --- CORE MUSIC THEORY LOGIC ---
        
        /**
         * Determines the standard quality text (Major, minor, diminished) for the current chord.
         * @returns {string} The formatted chord name (e.g., "C Major", "D minor").
         */
        function getChordName() {
            // 1. Determine the actual root note of the current chord
            const intervals = state.isMajor ? MAJOR_INTERVALS : MINOR_INTERVALS;
            // Get the interval for the current degree (e.g., ii is interval 2)
            const degreeInterval = intervals[state.currentDegree - 1]; 
            // Calculate the 0-11 index of the chord's root note
            const chordRootIndex = (state.currentKeyIndex + degreeInterval) % 12;
            // Get the name of the chord's root note (e.g., D for the ii chord in C)
            const chordRootName = KEYS[chordRootIndex]; 
            
            // 2. Determine the quality based on Roman numeral case
            const qualities = state.isMajor ? MAJOR_QUALITIES : MINOR_QUALITIES;
            const romanNumeral = qualities[state.currentDegree - 1];
            
            let qualityText = "";
            // Check for diminished symbol (째)
            if (romanNumeral.includes('째')) {
                qualityText = "diminished";
            } 
            // Check for uppercase (Major) or lowercase (minor) Roman numeral
            else if (romanNumeral === romanNumeral.toUpperCase()) {
                // Check if it's the dominant (V) in major, which is often just 'Major'
                if (state.isMajor && state.currentDegree === 5) {
                    qualityText = "Dominant"; // Or just "Major"
                } else {
                    qualityText = "Major";
                }
            } else {
                qualityText = "minor";
            }
            
            // 3. Combine the chord root name and the quality
            return `${chordRootName} ${qualityText}`;
        }

        function getScalePitchClasses(keyIndex, isMajor) {
            const intervals = isMajor ? MAJOR_INTERVALS : MINOR_INTERVALS;
            return intervals.map(interval => (keyIndex + interval) % 12);
        }

        function calculateTriadPitchClasses(keyIndex, isMajor, degree) {
            const scale = getScalePitchClasses(keyIndex, isMajor);
            const scaleDegreeIndex = degree - 1; 
            const root = scale[scaleDegreeIndex];
            const third = scale[(scaleDegreeIndex + 2) % 7];
            const fifth = scale[(scaleDegreeIndex + 4) % 7];
            return [root, third, fifth];
        }

        /**
         * Calculates the 3 specific MIDI notes for the triad, ensuring sequential movement.
         */
        function calculateSpecificTriadMidiNotes(keyIndex, isMajor, degree) {
            const scaleIntervals = isMajor ? MAJOR_INTERVALS : MINOR_INTERVALS;
            const scaleDegreeIndex = degree - 1; 

            // 1. Determine the CHORD ROOT MIDI note
            // Base MIDI is C4 (60). We want the I chord to start roughly in the middle octave (C4).
            const tonicMidiInStartingOctave = 60; // Always start C at C4

            // The root of the current chord moves up the keyboard diatonic-step by diatonic-step.
            // We use the root key index (e.g., +0 for C, +1 for C#, etc.) 
            // and the interval of the degree (e.g., +4 semitones for III in C Major)
            const rootMidi = tonicMidiInStartingOctave + keyIndex + scaleIntervals[scaleDegreeIndex];
            
            // 2. Calculate the semitone distance of the 3rd and 5th relative to the CHORD ROOT.
            const tonicIntervals = [
                scaleIntervals[scaleDegreeIndex],
                scaleIntervals[(scaleDegreeIndex + 2) % 7],
                scaleIntervals[(scaleDegreeIndex + 4) % 7]
            ];
            
            let semitoneOffsets = [0]; 

            let thirdInterval = tonicIntervals[1] - tonicIntervals[0];
            if (thirdInterval < 0) thirdInterval += 12; // Handle octave wrap (e.g., when the 3rd is the next octave's note)
            semitoneOffsets.push(thirdInterval);

            let fifthInterval = tonicIntervals[2] - tonicIntervals[0];
            if (fifthInterval < 0) fifthInterval += 12; // Handle octave wrap
            semitoneOffsets.push(fifthInterval);
            
            // 3. Build the final triad MIDI notes
            const triadMidiNotes = semitoneOffsets.map(offset => rootMidi + offset);

            // Filter out notes outside our visible keyboard range (START_MIDI to END_MIDI)
            return triadMidiNotes.filter(midi => midi >= START_MIDI && midi <= END_MIDI);
        }

        // --- SVG RENDERING LOGIC ---

        /**
         * Calculates the X position for a given absolute MIDI index.
         */
        function getKeyXPosition(absoluteIndex) {
            const noteMod12 = absoluteIndex % 12;
            const isWhiteKey = [0, 2, 4, 5, 7, 9, 11].includes(noteMod12);
            
            const WKW = KEYBOARD_CONFIG.WHITE_KEY_WIDTH;
            const BKW = KEYBOARD_CONFIG.BLACK_KEY_WIDTH;

            let whiteKeyCount = 0;
            // Count white keys from the start of the visualization range (C4 = 60) up to this key
            for (let i = START_MIDI; i < absoluteIndex; i++) {
                if ([0, 2, 4, 5, 7, 9, 11].includes(i % 12)) whiteKeyCount++;
            }

            if (isWhiteKey) {
                return whiteKeyCount * WKW;
            } else {
                // Position black key relative to the start of the first white key it sits on top of
                // C# (61) sits on C (60). White key count for 60 is 0. Position is 0*WKW + offset.
                // The black keys are centered over the boundary, but positioned using the left white key's edge.
                let whiteKeysBefore = 0;
                for (let i = START_MIDI; i <= absoluteIndex; i++) {
                     if ([0, 2, 4, 5, 7, 9, 11].includes(i % 12)) whiteKeysBefore++;
                }
                // Black key position: start of the white key *after* it, minus half the black key width.
                // Special handling for the position on C, D, F, G, A
                // C# is at the edge of the C key. D# is at the edge of the D key.
                const whiteKeyIndex = whiteKeysBefore; // The index of the white key to the left
                
                // Fine-tuned offsets for black keys relative to the white keys:
                // C#: -0.5 key width from D key start (WKW * 1)
                // D#: -0.5 key width from E key start (WKW * 2)
                // F#: -0.5 key width from G key start (WKW * 3)
                // G#: -0.5 key width from A key start (WKW * 4)
                // A#: -0.5 key width from B key start (WKW * 5)

                // This logic is complex. The original method was more direct:
                // Position is based on the number of white keys before it, minus half the black key width.
                // whiteKeyCount already calculated white keys *before* the current note.
                return (whiteKeyCount * WKW) + WKW - (BKW / 2) - 1.5 * WKW;
            }
        }

        // The previous getKeyXPosition logic was slightly off for black keys.
        // Let's use a standard implementation that is less complex:
        function getWhiteKeyIndex(midi) {
            let whiteKeyIndex = 0;
            for (let i = START_MIDI; i < midi; i++) {
                if ([0, 2, 4, 5, 7, 9, 11].includes(i % 12)) {
                    whiteKeyIndex++;
                }
            }
            return whiteKeyIndex;
        }

        function getKeyXPositionRevised(midi) {
            const pitchClass = midi % 12;
            const isWhiteKey = [0, 2, 4, 5, 7, 9, 11].includes(pitchClass);
            const WKW = KEYBOARD_CONFIG.WHITE_KEY_WIDTH;
            const BKW = KEYBOARD_CONFIG.BLACK_KEY_WIDTH;

            const whiteKeyIndex = getWhiteKeyIndex(midi);

            if (isWhiteKey) {
                return whiteKeyIndex * WKW;
            } else {
                // Black keys are placed relative to the white key *to its left*.
                // Black key positions (relative to C):
                // C#: Over C/D boundary. White key index is C's index. Offset: WKW - BKW/2
                // D#: Over D/E boundary. White key index is D's index. Offset: 2*WKW - BKW/2
                
                // The white key index *before* the black key:
                let baseWhiteIndex = whiteKeyIndex; 
                
                switch (pitchClass) {
                    case 1: // C# / Db
                    case 3: // D# / Eb
                    case 6: // F# / Gb
                    case 8: // G# / Ab
                    case 10: // A# / Bb
                        // The position is based on the edge of the white key to its left.
                        // We need the number of white keys *before* this black key.
                        return baseWhiteIndex * WKW + WKW - (BKW / 2);
                    default:
                        // This case should not be hit for black keys, but as a fallback:
                        return baseWhiteIndex * WKW;
                }
            }
        }
        
        /**
         * Draws the entire keyboard using SVG based on the current state.
         */
        function drawKeyboard() {
            const svg = document.getElementById('piano-keyboard-svg');
            const highlightedMidiNotes = state.triadMidiNotes; 
            
            svg.setAttribute('width', `${KEYBOARD_CONFIG.KEYBOARD_WIDTH}px`);
            svg.setAttribute('viewBox', `0 0 ${KEYBOARD_CONFIG.KEYBOARD_WIDTH} ${KEYBOARD_CONFIG.KEYBOARD_HEIGHT}`);
            svg.innerHTML = ''; // Clear previous drawing

            const WKW = KEYBOARD_CONFIG.WHITE_KEY_WIDTH;
            const BKW = KEYBOARD_CONFIG.BLACK_KEY_WIDTH;
            const WKH = KEYBOARD_CONFIG.WHITE_KEY_HEIGHT;
            const Y_START = KEYBOARD_CONFIG.KEY_Y_START;
            
            // 1. Draw White Keys first
            PIANO_KEY_DATA.forEach(key => {
                if (key.isWhite) {
                    const isHighlighted = highlightedMidiNotes.includes(key.midi); 
                    const x = getWhiteKeyIndex(key.midi) * WKW; // Simpler positioning for white keys

                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute('x', x);
                    rect.setAttribute('y', Y_START);
                    rect.setAttribute('width', WKW);
                    rect.setAttribute('height', WKH);
                    rect.setAttribute('rx', 4); // Rounded corners
                    rect.setAttribute('ry', 4);
                    rect.setAttribute('stroke', '#a1a1aa');
                    rect.setAttribute('stroke-width', '1');
                    rect.setAttribute('fill', isHighlighted ? KEY_COLORS.HIGHLIGHT_WHITE : KEY_COLORS.WHITE);
                    rect.classList.add('highlight-transition'); 
                    
                    svg.appendChild(rect);

                    // --- Labeling Logic for White Keys ---
                    let labelText = null;
                    let labelFill = isHighlighted ? KEY_COLORS.WHITE : '#4b5563'; 

                    if (isHighlighted) {
                        // Display the root note of the chord on the key
                        const rootPitchClass = state.triadPitchClasses[0];
                        if (key.pitchClass === rootPitchClass) {
                            labelText = KEYS[rootPitchClass]; // Show root name only on the root key
                        }
                    } else if (key.name === 'C' || key.name === 'F') {
                        // Octave calculation: (MIDI / 12) - 1. E.g., C4 (60) -> (60/12)-1 = 4
                        labelText = `${key.name}${Math.floor(key.midi / 12) - 1}`;
                    }

                    if (labelText) {
                        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        text.setAttribute('x', x + WKW / 2);
                        text.setAttribute('y', Y_START + WKH - 10);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('font-size', '14');
                        text.setAttribute('font-weight', '600');
                        text.setAttribute('fill', labelFill);
                        text.textContent = labelText;
                        svg.appendChild(text);
                    }
                }
            });

            // 2. Draw Black Keys second (to place them on top)
            PIANO_KEY_DATA.forEach(key => {
                if (!key.isWhite) {
                    const isHighlighted = highlightedMidiNotes.includes(key.midi);
                    
                    // Black keys are tricky. Determine the index of the white key to the left.
                    const leftWhiteKeyMidi = key.midi - 1;
                    let whiteKeyIndex = getWhiteKeyIndex(leftWhiteKeyMidi);

                    // Offset the black key X position relative to the left white key's edge:
                    let xOffset = 0;
                    switch (key.pitchClass) {
                        case 1: xOffset = WKW - (BKW / 2); break; // C# / Db (Over C)
                        case 3: xOffset = WKW - (BKW / 2); break; // D# / Eb (Over D)
                        case 6: xOffset = WKW - (BKW / 2); break; // F# / Gb (Over F)
                        case 8: xOffset = WKW - (BKW / 2); break; // G# / Ab (Over G)
                        case 10: xOffset = WKW - (BKW / 2); break; // A# / Bb (Over A)
                    }

                    const x = (whiteKeyIndex * WKW) + xOffset - WKW * 0.5; // Final adjustment for centering

                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute('x', x);
                    rect.setAttribute('y', Y_START);
                    rect.setAttribute('width', BKW);
                    rect.setAttribute('height', KEYBOARD_CONFIG.BLACK_KEY_HEIGHT);
                    rect.setAttribute('rx', 3); 
                    rect.setAttribute('ry', 3);
                    rect.setAttribute('stroke', '#000000');
                    rect.setAttribute('stroke-width', '1');
                    rect.setAttribute('fill', isHighlighted ? KEY_COLORS.HIGHLIGHT_BLACK : KEY_COLORS.BLACK);
                    rect.classList.add('highlight-transition'); 

                    svg.appendChild(rect);
                    
                    if (isHighlighted) {
                        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        text.setAttribute('x', x + BKW / 2);
                        text.setAttribute('y', Y_START + KEYBOARD_CONFIG.BLACK_KEY_HEIGHT - 10);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('font-size', '14');
                        text.setAttribute('font-weight', '600');
                        text.setAttribute('fill', KEY_COLORS.WHITE);
                        text.textContent = key.name;
                        svg.appendChild(text);
                    }
                }
            });
            
            const pianoContainer = document.getElementById('piano-container');
            
            // --- CONDITIONAL SCROLLING LOGIC ---
            if (state.isCenteringEnabled && state.triadMidiNotes.length > 0) {
                // Centering is enabled: calculate scroll position to center the chord's root (first note)
                const centerMidi = state.triadMidiNotes[0]; 
                
                let centerScrollX = 0;
                const centerKeyData = PIANO_KEY_DATA.find(k => k.midi === centerMidi);
                
                if (centerKeyData) {
                    // Use the original X position calculation for centering simplicity
                    const centerKeyX = centerKeyData.isWhite ? getWhiteKeyIndex(centerKeyData.midi) * WKW : getKeyXPositionRevised(centerKeyData.midi);
                    const containerWidth = pianoContainer.offsetWidth;
                    
                    const keyWidth = centerKeyData.isWhite ? WKW : BKW;
                    centerScrollX = centerKeyX - (containerWidth / 2) + (keyWidth / 2);

                    centerScrollX = Math.max(0, centerScrollX);
                    // Prevent scrolling past the far right
                    centerScrollX = Math.min(KEYBOARD_CONFIG.KEYBOARD_WIDTH - containerWidth, centerScrollX);
                }
                
                requestAnimationFrame(() => {
                    pianoContainer.scrollLeft = centerScrollX;
                });
            } else if (!state.isCenteringEnabled) {
                // Centering is disabled: keep the scroll position at the far left (Fixed)
                requestAnimationFrame(() => {
                    pianoContainer.scrollLeft = 0;
                });
            }
        }
        
        function renderKeySelect() {
            const select = document.getElementById('key-select');
            select.innerHTML = KEYS.map((key, index) => 
                `<option value="${index}" ${index === state.currentKeyIndex ? 'selected' : ''}>${key}</option>`
            ).join('');
        }
        
        function renderModeButtons() {
            const majorBtn = document.getElementById('major-mode-btn');
            const minorBtn = document.getElementById('minor-mode-btn');

            if (state.isMajor) {
                majorBtn.className = 'flex-1 py-3 px-4 rounded-lg font-bold transition duration-200 shadow-md bg-blue-600 text-white hover:bg-blue-700';
                minorBtn.className = 'flex-1 py-3 px-4 rounded-lg font-bold transition duration-200 shadow-md bg-gray-200 text-gray-700 hover:bg-gray-300 border border-gray-300';
            } else {
                majorBtn.className = 'flex-1 py-3 px-4 rounded-lg font-bold transition duration-200 shadow-md bg-gray-200 text-gray-700 hover:bg-gray-300 border border-gray-300';
                minorBtn.className = 'flex-1 py-3 px-4 rounded-lg font-bold transition duration-200 shadow-md bg-blue-600 text-white hover:bg-blue-700';
            }
        }

        function renderChordButtons() {
            const container = document.getElementById('chord-buttons-container');
            const qualities = state.isMajor ? MAJOR_QUALITIES : MINOR_QUALITIES;
            
            container.innerHTML = qualities.map((quality, index) => {
                const degree = index + 1;
                const isActive = degree === state.currentDegree;
                
                return `
                    <button onclick="handleDegreeChange(${degree})"
                            class="py-3 px-2 rounded-lg font-extrabold text-lg transition duration-200 shadow-lg 
                            ${isActive 
                                ? 'bg-blue-700 text-white ring-4 ring-blue-300 transform scale-105' 
                                : 'bg-gray-100 text-gray-700 hover:bg-gray-300'
                            }">
                        ${quality}
                    </button>
                `;
            }).join('');
        }

        function renderChordName() {
            document.getElementById('current-chord-display').textContent = getChordName();
        }
        
        // --- HANDLERS ---
        
        function updateUI() {
            state.triadPitchClasses = calculateTriadPitchClasses(
                state.currentKeyIndex, 
                state.isMajor, 
                state.currentDegree
            );
            
            state.triadMidiNotes = calculateSpecificTriadMidiNotes(
                state.currentKeyIndex, 
                state.isMajor, 
                state.currentDegree
            );
            
            renderKeySelect();
            renderModeButtons();
            renderChordButtons();
            renderChordName(); // Display the correct chord name
            drawKeyboard(); 
        }

        function handleKeyChange(keyIndex) {
            state.currentKeyIndex = parseInt(keyIndex);
            state.currentDegree = 1; 
            updateUI();
        }

        function handleModeChange(isMajor) {
            state.isMajor = isMajor;
            state.currentDegree = 1; 
            updateUI();
        }

        function handleDegreeChange(degree) {
            state.currentDegree = degree;
            updateUI();
        }
        
        function toggleCentering(checked) {
            state.isCenteringEnabled = checked;
            drawKeyboard();
        }


        // --- PWA INITIALIZATION ---
        
        function registerPwa() {
            // 1. Service Worker Definition (Caching)
            const swCode = `
                const CACHE_NAME = 'theoryviz-v1';
                // Cache the main application file (this HTML page)
                const urlsToCache = ['./'];

                self.addEventListener('install', (event) => {
                    console.log('[Service Worker] Installing...');
                    self.skipWaiting();
                    event.waitUntil(
                        caches.open(CACHE_NAME)
                            .then((cache) => {
                                console.log('[Service Worker] Caching app shell');
                                return cache.addAll(urlsToCache);
                            })
                            .catch(err => console.error('[Service Worker] Caching failed:', err))
                    );
                });

                self.addEventListener('activate', (event) => {
                    console.log('[Service Worker] Activating...');
                    const cacheWhitelist = [CACHE_NAME];
                    event.waitUntil(
                        caches.keys().then((cacheNames) => {
                            return Promise.all(
                                cacheNames.map((cacheName) => {
                                    if (cacheWhitelist.indexOf(cacheName) === -1) {
                                        console.log('[Service Worker] Deleting old cache:', cacheName);
                                        return caches.delete(cacheName);
                                    }
                                })
                            );
                        })
                    );
                });

                self.addEventListener('fetch', (event) => {
                    // Cache-first strategy for the app shell
                    event.respondWith(
                        caches.match(event.request, { ignoreSearch: true })
                            .then((response) => {
                                // Cache hit - return response
                                if (response) {
                                    return response;
                                }
                                // Fallback to network (important for Tailwind CSS CDN)
                                return fetch(event.request);
                            })
                    );
                });
            `;
            
            // 2. Register Service Worker using a Blob URL
            if ('serviceWorker' in navigator) {
                try {
                    const swBlob = new Blob([swCode], { type: 'application/javascript' });
                    const swUrl = URL.createObjectURL(swBlob);
                    
                    navigator.serviceWorker.register(swUrl, { scope: './' })
                        .then(registration => {
                            console.log('ServiceWorker registration successful with scope: ', registration.scope);
                        })
                        .catch(err => {
                            console.error('ServiceWorker registration failed: ', err);
                        });
                } catch (error) {
                    console.error('Failed to create Service Worker Blob:', error);
                }
            }

            // 3. Web App Manifest Definition
            const manifestContent = {
                "name": "TheoryViz",
                "short_name": "TheoryViz",
                "description": "Visualize music harmony and chords on a piano keyboard.",
                "start_url": "./",
                "display": "standalone",
                "orientation": "portrait",
                "background_color": "#ffffff",
                "theme_color": "#3b82f6",
                "icons": [
                    {"src": "https://placehold.co/192x192/3b82f6/ffffff?text=TV", "sizes": "192x192", "type": "image/png"},
                    {"src": "https://placehold.co/512x512/3b82f6/ffffff?text=TV", "sizes": "512x512", "type": "image/png"}
                ]
            };

            // 4. Create Manifest Data URI and link it
            const manifestBlob = new Blob([JSON.stringify(manifestContent)], {type : 'application/json'});
            const manifestUrl = URL.createObjectURL(manifestBlob);
            
            const link = document.createElement('link');
            link.rel = 'manifest';
            link.href = manifestUrl;
            document.head.appendChild(link);
            
            console.log('Manifest linked successfully.');
        }

        // --- APPLICATION STARTUP ---
        
        window.onload = () => {
            // Re-initialize PIANO_KEY_DATA (already done at the top but re-running just in case)
             PIANO_KEY_DATA.length = 0;
             for (let i = START_MIDI; i <= END_MIDI; i++) {
                 PIANO_KEY_DATA.push({
                     midi: i,
                     pitchClass: i % 12,
                     name: KEYS[i % 12],
                     isWhite: MAJOR_INTERVALS.includes(i % 12),
                 });
             }
             updateUI();
             registerPwa(); // Call PWA registration on load
        };

        window.addEventListener('resize', updateUI); 
        
    </script>
</body>
</html>
