<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TheoryViz</title>
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#3b82f6">
    <!-- The manifest link will be dynamically created by JS later -->

    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the SVG keyboard container */
        .keyboard-container {
            position: relative;
            /* Height remains 250px to accommodate the step visualizer track */
            height: 250px; 
            margin-top: 20px;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            /* Light gray for contrast against the white keys */
            background-color: #f3f4f6;
            overflow-x: scroll; /* Keeps the keyboard scrollable */
            overscroll-behavior: contain; /* Prevents unwanted browser scroll on mobile drag */
        }

        /* Highlighting Styles for a consistent look with the buttons */
        .highlight-transition {
            transition: fill 0.2s ease;
        }

        /* Hide scrollbar for a cleaner look, while still allowing scroll */
        .keyboard-container::-webkit-scrollbar {
            display: none;
        }
        .keyboard-container {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        
        /* Specific highlight for the active NOTE (solid fill) */
        .note-block-active {
            background-color: #3b82f6 !important; /* bg-blue-500 */
            color: white !important;
            box-shadow: 0 4px 6px -1px rgba(59, 130, 246, 0.5); /* shadow-lg with blue tint */
            transform: scale(1.12);
            border-color: #3b82f6 !important; /* Set border to match background */
        }

        /* Custom style for segmented control buttons */
        .segmented-btn {
            border-radius: 0.375rem; /* rounded-md */
            transition: all 0.2s;
            font-weight: 600; /* font-semibold */
        }
        .segmented-btn.active {
            background-color: #3b82f6; /* blue-600 */
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 10;
        }
        .segmented-btn:first-child {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }
        .segmented-btn:last-child {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }

    </style>
</head>
<body class="bg-gray-50 font-sans p-4 md:p-8">

    <div class="max-w-6xl mx-auto bg-white rounded-xl shadow-2xl p-6 md:p-10">
        <h1 class="text-3xl md:text-4xl font-extrabold text-gray-800 mb-3 text-center">
            TheoryViz
        </h1>
        <p class="text-center text-gray-600 mb-6">
            Visualize harmony anywhere!
        </p>

        <!-- CONSOLIDATED CONTROL PANEL -->
        <div class="p-4 bg-gray-100 rounded-xl mb-6 shadow-inner border border-gray-200">
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            
                <!-- 1. Key Selection -->
                <div class="w-full">
                    <label for="key-select" class="block text-sm font-medium text-gray-700 mb-1">Root Key</label>
                    <select id="key-select" onchange="handleKeyChange(event.target.value)"
                            class="w-full p-3 border border-gray-300 rounded-lg bg-white text-gray-800 focus:ring-blue-500 focus:border-blue-500 shadow-sm transition">
                        <!-- Options populated by JS -->
                    </select>
                </div>

                <!-- 2. Mode Selection (Type) -->
                <div class="w-full">
                    <label for="mode-select" class="block text-sm font-medium text-gray-700 mb-1">Scale Type</label>
                    <select id="mode-select" onchange="handleModeChange(event.target.value)"
                            class="w-full p-3 border border-gray-300 rounded-lg bg-white text-gray-800 focus:ring-blue-500 focus:border-blue-500 shadow-sm transition">
                        <!-- Options populated by JS -->
                    </select>
                </div>
                
                <!-- 3. Visualization Mode Toggle (Chord/Scale) -->
                <div class="w-full">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Visualization</label>
                    <div id="mode-toggle-container" class="flex w-full border border-gray-300 rounded-lg overflow-hidden bg-white shadow-sm">
                        <!-- Buttons populated by JS -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Current Chord/Note Name Display -->
        <div class="mt-6 mb-4 text-center">
            <p class="text-xl font-semibold text-gray-700">Current Highlight:</p>
            <h2 id="current-chord-display" class="text-4xl font-extrabold text-blue-600 mt-1">
                <!-- Note and degree name will be displayed here, e.g., C Major (I) -->
            </h2>
        </div>
        
        <!-- Simplified Inversion Interaction Tip -->
        <div class="mb-4 py-2 px-3 bg-blue-100/50 border border-blue-200/80 text-blue-800 text-sm rounded-lg text-center font-medium">
            Click the **active** Roman numeral to cycle inversions (Root, 1st, 2nd) in Chord View.
        </div>

        <!-- Chord Buttons (Scale Degree Selector) -->
        <div id="chord-buttons-container" class="mt-8 grid grid-cols-4 sm:grid-cols-7 gap-3">
            <!-- Buttons will be dynamically generated here -->
        </div>

        <!-- Piano Keyboard Container (Handles Scrolling for both steps and keys) -->
        <div id="piano-container" class="keyboard-container overflow-x-scroll pb-4">
            <!-- New track for whole/half step visualization. It must have the exact width of the SVG (1080px) to scroll correctly. -->
            <div id="step-visualizer-track" style="width: 1080px; position: relative; height: 30px;" class="mt-1 mb-1">
                <!-- Step indicators will be absolutely positioned here by JS -->
            </div>
            <svg id="piano-keyboard-svg" width="100%" height="200" preserveAspectRatio="xMinYMin slice"></svg>
        </div>
        
        <!-- Keyboard Scroll Toggle (Subtle placement below the keyboard) -->
        <div class="mt-2 flex justify-center">
            <div class="flex items-center p-1 bg-white border border-gray-300 rounded-full shadow-md">
                <span class="text-xs font-medium text-gray-600 select-none mr-2 ml-1">Fixed Scroll</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="centering-toggle" class="sr-only peer" checked onchange="toggleCentering(event.target.checked)">
                    <div class="w-8 h-4 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:rounded-full after:h-3.5 after:w-3.5 after:transition-all peer-checked:bg-blue-500"></div>
                </label>
                <span class="text-xs font-medium text-blue-600 select-none ml-2 mr-1">Centering</span>
            </div>
        </div>
        
    </div>

    <script>
        // --- CONSTANTS AND MAPPING ---
        const KEYS = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const MAJOR_INTERVALS = [0, 2, 4, 5, 7, 9, 11]; 
        
        // Inversion Options (kept for reference, though logic is in handleDegreeChange)
        const INVERSION_OPTIONS = [
            { value: 0, label: 'Root Position' },
            { value: 1, label: 'First Inversion (6)' },
            { value: 2, label: 'Second Inversion (6/4)' }
        ];

        const SCALE_MODES = {
            'major': {
                name: 'Ionian (Major)',
                intervals: [0, 2, 4, 5, 7, 9, 11],
                steps: ["W", "W", "H", "W", "W", "W", "H"],
                // Degrees: I, ii, iii, IV, V, vi, vii°, VIII (I/Maj)
                triadQualities: ["Maj", "min", "min", "Maj", "Maj", "min", "dim", "Maj"], 
                qualities: ["I", "ii", "iii", "IV", "V", "vi", "vii°", "VIII (I)"], 
                chordSteps: [0, 2, 4], 
                degrees: 8, 
                isDiatonic: true
            },
            'natural_minor': {
                name: 'Aeolian (Natural Minor)',
                intervals: [0, 2, 3, 5, 7, 8, 10],
                steps: ["W", "H", "W", "W", "H", "W", "W"],
                // Degrees: i, ii°, III, iv, v, VI, VII (Maj), viii (i/min)
                triadQualities: ["min", "dim", "Maj", "min", "min", "Maj", "Maj", "min"],
                qualities: ["i", "ii°", "III", "iv", "v", "VI", "VII", "viii (i)"],
                chordSteps: [0, 2, 4],
                degrees: 8,
                isDiatonic: true
            },
            'harmonic_minor': {
                name: 'Harmonic Minor',
                intervals: [0, 2, 3, 5, 7, 8, 11], 
                steps: ["W", "H", "W", "W", "H", "1.5", "H"], 
                // Degrees: i, ii°, III+, iv, V, VI, vii° (dim), viii (i/min)
                triadQualities: ["min", "dim", "Aug", "min", "Maj", "Maj", "dim", "min"], 
                qualities: ["i", "ii°", "III+", "iv", "V", "VI", "vii°", "viii (i)"],
                chordSteps: [0, 2, 4],
                degrees: 8, 
                isDiatonic: true
            },
            'major_pentatonic': { // Excluded from Chord View
                name: 'Major Pentatonic',
                intervals: [0, 2, 4, 7, 9],
                steps: ["W", "W", "1.5", "W", "1.5"], 
                triadQualities: ["", "", "", "", ""], 
                qualities: ["1", "2", "3", "4", "5"], 
                chordSteps: [0], 
                degrees: 5,
                isDiatonic: false // Key flag for filtering
            },
            'minor_pentatonic': { // Excluded from Chord View
                name: 'Minor Pentatonic',
                intervals: [0, 3, 5, 7, 10],
                steps: ["1.5", "W", "W", "1.5", "W"],
                triadQualities: ["", "", "", "", ""],
                qualities: ["1", "2", "3", "4", "5"], 
                chordSteps: [0],
                degrees: 5,
                isDiatonic: false // Key flag for filtering
            }
        };
        
        // MIDI note range for the visual keyboard: C4 (60) to F6 (89) -> 30 keys (3 octaves)
        const START_MIDI = 60; // C4 (Middle C)
        const END_MIDI = 89;   // F6
        
        // --- SVG KEYBOARD CONFIGURATION ---
        const KEYBOARD_CONFIG = {
            TOTAL_KEYS_RANGE: END_MIDI - START_MIDI + 1, 
            WHITE_KEYS_COUNT: 18,
            KEYBOARD_WIDTH: 1080,
            KEYBOARD_HEIGHT: 200,
            KEY_Y_START: 10,
            WHITE_KEY_HEIGHT: 180,
            WHITE_KEY_WIDTH: 1080 / 18, 
            BLACK_KEY_WIDTH: (1080 / 18) * 0.6, 
            BLACK_KEY_HEIGHT: 110,
        };

        const KEY_COLORS = {
            WHITE: '#ffffff',
            BLACK: '#1f2937',
            HIGHLIGHT_WHITE: '#3b82f6',
            HIGHLIGHT_BLACK: '#2563eb'
        };
        
        const PIANO_KEY_DATA = [];
        

        // --- STATE ---
        let state = {
            currentKeyIndex: 0, // C is default
            currentModeId: 'major', 
            currentDegree: 1, 
            currentInversion: 0, 
            highlightedPitchClasses: [], 
            highlightedMidiNotes: [], 
            isCenteringEnabled: true, 
            visualizationMode: 'scale' 
        };

        // --- CORE MUSIC THEORY LOGIC ---
        
        function getCurrentMode() {
            return SCALE_MODES[state.currentModeId];
        }

        /**
         * Gets the display name for the current highlight, showing the full chord name or scale degree. (REVERTED)
         */
        function getHighlightName() {
            const mode = getCurrentMode();
            const intervals = mode.intervals;
            const degree = state.currentDegree;

            // Calculate the interval offset 
            let degreeInterval;
            if (degree === 8) {
                degreeInterval = 12;
            } else {
                // Adjust interval if the mode has fewer than 7 steps (e.g., pentatonic)
                if (degree > intervals.length) {
                    degreeInterval = 0; // Default to root if out of bounds
                } else {
                    degreeInterval = intervals[degree - 1]; 
                }
            }
            
            const highlightRootIndex = (state.currentKeyIndex + degreeInterval) % 12;
            const highlightRootName = KEYS[highlightRootIndex]; 
            
            // The degree index for Roman numeral/quality is always 0-based
            const degreeIndex = (degree === 8) ? 0 : degree - 1;

            // Check if we can display full chord context (Chord View, Diatonic, 7-note scale)
            if (state.visualizationMode === 'chord' && mode.isDiatonic && mode.intervals.length === 7) {
                 // Chord View: Show Root + Quality + Roman Numeral + Inversion
                const romanNumeral = mode.qualities[degreeIndex];
                const quality = mode.triadQualities[degreeIndex];
                
                let inversionSuffix = '';
                if (state.currentInversion === 1) {
                    inversionSuffix = ' (1st Inv.)';
                } else if (state.currentInversion === 2) {
                    inversionSuffix = ' (2nd Inv.)';
                }

                // Example: C Maj (I) (Root Position)
                return `${highlightRootName} ${quality} (${romanNumeral})${inversionSuffix}`;
            } else {
                // Scale View (and non-diatonic/non-7-note scales): Show Note + Ordinal
                let degreeText;
                if (degree === 1) {
                    degreeText = '1st';
                } else if (degree === 2) {
                    degreeText = '2nd';
                } else if (degree === 3) {
                    degreeText = '3rd';
                } else if (degree === 8) {
                    degreeText = 'Octave 8th';
                } else {
                    degreeText = `${degree}th`;
                }
                
                // Example: C (1st)
                return `${highlightRootName} (${degreeText})`;
            }
        }


        /**
         * Calculates the specific MIDI notes for the selected chord, applying the current inversion.
         */
        function calculateChordMidiNotes(keyIndex, degree, inversion) {
            const mode = getCurrentMode();
            const scaleIntervals = mode.intervals;
            
            // Map degree 8 to degree 1 for interval/quality lookup, but set an octave shift
            const octaveShift = (degree === 8) ? 12 : 0;
            // The degree index for calculating R-3-5 intervals is always 0-6 (relative to the scale)
            const scaleDegreeIndex = (degree === 8) ? 0 : degree - 1; 
            
            const tonicMidiInStartingOctave = 60; 

            if (!mode.isDiatonic || mode.intervals.length < 7 || state.visualizationMode === 'scale') {
                 // For non-diatonic or scale view, fall back to single note calculation
                 return calculateSingleScaleMidiNote(keyIndex, degree);
            }
            
            // 1. Determine the component scale degrees (0-based) for the chord (R, 3rd, 5th)
            const stepsInChord = mode.chordSteps; // [0, 2, 4] for R, 3, 5
            
            // 2. Calculate the base MIDI notes (Root Position, all relative to the chord's root)
            
            const rootIntervalFromTonic = scaleIntervals[scaleDegreeIndex];
            const lowestRootMidi = tonicMidiInStartingOctave + keyIndex + rootIntervalFromTonic;
            
            // Determine the indexes of the 3rd and 5th within the scale (must use 7 as the modulus)
            const scaleLength = mode.intervals.length; // This is 7 for 7-note scales
            
            const thirdIndex = (scaleDegreeIndex + stepsInChord[1]) % scaleLength;
            const fifthIndex = (scaleDegreeIndex + stepsInChord[2]) % scaleLength;

            // Calculate semitone offsets relative to the chord's root (lowestRootMidi)
            
            let semitoneOffsetThird = scaleIntervals[thirdIndex] - scaleIntervals[scaleDegreeIndex];
            if (semitoneOffsetThird < 0) semitoneOffsetThird += 12; 
            
            let semitoneOffsetFifth = scaleIntervals[fifthIndex] - scaleIntervals[scaleDegreeIndex];
            if (semitoneOffsetFifth < 0) semitoneOffsetFifth += 12; 

            let chordComponents = [
                lowestRootMidi, 
                lowestRootMidi + semitoneOffsetThird, 
                lowestRootMidi + semitoneOffsetFifth  
            ];
            
            // Apply the octave shift (12 semitones) if degree 8 was selected
            if (octaveShift === 12) {
                chordComponents = chordComponents.map(midi => midi + 12);
            }

            // 3. Apply Inversion (Mutate chordComponents)
            // Inversions are only allowed for degrees 1-7.
            if (degree <= 7) {
                for (let i = 0; i < inversion; i++) {
                    const lowestNote = chordComponents.shift(); 
                    chordComponents.push(lowestNote + 12);     
                }
            }
            
            // 4. Filter to the visible keyboard range
            return chordComponents.filter(midi => midi >= START_MIDI && midi <= END_MIDI);
        }

        /**
         * Calculates the specific MIDI note for the root of the selected scale degree. Used in Scale View.
         */
        function calculateSingleScaleMidiNote(keyIndex, degree) {
            const scaleIntervals = getCurrentMode().intervals;
            
            // The 8th degree is the octave (interval 12)
            let intervalOffset;
            if (degree === 8) {
                intervalOffset = 12;
            } else {
                // Adjust interval if the mode has fewer than 7 steps (e.g., pentatonic)
                if (degree > scaleIntervals.length) {
                    intervalOffset = scaleIntervals[0]; // Fallback to root if out of bounds
                } else {
                    intervalOffset = scaleIntervals[degree - 1];
                }
            }

            const tonicMidiInStartingOctave = 60; 

            const rootMidi = tonicMidiInStartingOctave + keyIndex + intervalOffset;
            
            return [rootMidi].filter(midi => midi >= START_MIDI && midi <= END_MIDI);
        }
        
        // --- RENDERING FUNCTIONS ---
        
        /**
         * Calculates the 0-based index of a white key, counting from START_MIDI (C4).
         */
        function getWhiteKeyIndex(midi) {
            let count = 0;
            for (let i = START_MIDI; i <= midi; i++) {
                 if ([0, 2, 4, 5, 7, 9, 11].includes(i % 12)) {
                     count++;
                 }
            }
            return count - 1; 
        }

        /**
         * Calculates the X position of a key based on its MIDI number (start of the key).
         */
        function getKeyXPosition(midi) {
            const pitchClass = midi % 12;
            const isWhiteKey = [0, 2, 4, 5, 7, 9, 11].includes(pitchClass);
            const WKW = KEYBOARD_CONFIG.WHITE_KEY_WIDTH;
            const BKW = KEYBOARD_CONFIG.BLACK_KEY_WIDTH;

            const whiteKeyIndex = getWhiteKeyIndex(midi);

            if (isWhiteKey) {
                return whiteKeyIndex * WKW;
            } else {
                const leftWhiteKeyIndex = getWhiteKeyIndex(midi - 1);
                const leftWhiteKeyX = leftWhiteKeyIndex * WKW;
                const seamX = leftWhiteKeyX + WKW;
                return seamX - (BKW / 2); 
            }
        }
        
        /**
         * Helper to get key center X position.
         */
        function getKeyCenterX(midi) {
            const pitchClass = midi % 12;
            const x = getKeyXPosition(midi);
            const isWhite = [0, 2, 4, 5, 7, 9, 11].includes(pitchClass);
            const WKW = KEYBOARD_CONFIG.WHITE_KEY_WIDTH;
            const BKW = KEYBOARD_CONFIG.BLACK_KEY_WIDTH;
            return x + (isWhite ? WKW / 2 : BKW / 2);
        }

        /**
         * Renders the W/H/1.5 step indicators in the track above the keyboard.
         */
        function renderStepVisualizer() {
            const track = document.getElementById('step-visualizer-track');
            
            // Always clear the track first
            track.innerHTML = ''; 

            // Only proceed with drawing if we are in Scale View
            if (state.visualizationMode === 'chord') {
                return;
            }

            const mode = getCurrentMode();
            const scaleSteps = mode.steps;
            const scaleIntervals = mode.intervals;
            
            // The MIDI of the tonic in the starting octave (C4 + Key Offset)
            const referenceMidi = START_MIDI + state.currentKeyIndex;

            // Iterate through the steps 
            for (let i = 0; i < scaleSteps.length; i++) { 
                const step = scaleSteps[i];
                
                // 1. Get MIDI of the current note (Start of the step)
                const currentNoteMidi = referenceMidi + scaleIntervals[i];

                // 2. Calculate MIDI of the next note (End of the step)
                let stepInSemitones;
                
                if (i === scaleSteps.length - 1) {
                    // Last step wraps to the octave above the tonic
                    stepInSemitones = 12 - scaleIntervals[i];
                } else {
                    // Normal step to the next scale interval
                    stepInSemitones = scaleIntervals[i + 1] - scaleIntervals[i];
                }

                // If stepInSemitones is 0 or less, skip drawing (shouldn't happen with correct data)
                if (stepInSemitones <= 0) continue; 

                const nextNoteMidi = currentNoteMidi + stepInSemitones;

                // 3. Get X positions of the centers
                const x1 = getKeyCenterX(currentNoteMidi);
                const x2 = getKeyCenterX(nextNoteMidi);

                // 4. Calculate midpoint for placement
                const centerX = (x1 + x2) / 2;
                
                // 5. Determine styling and label
                let stepColorClass;
                let tooltipText;
                let stepLabel;

                if (step === 'W') { 
                    stepColorClass = 'bg-green-600'; 
                    tooltipText = 'Whole Step';
                    stepLabel = 'W';
                } else if (step === 'H') { 
                    stepColorClass = 'bg-red-600'; 
                    tooltipText = 'Half Step';
                    stepLabel = 'H';
                } else if (step === '1.5') { 
                    stepColorClass = 'bg-purple-600'; 
                    tooltipText = 'Augmented Step (1.5)';
                    stepLabel = 'A'; // Use 'A' for augmented step for size
                } else {
                    continue; 
                }
                
                // 6. Create the indicator element
                const indicator = document.createElement('div');
                indicator.className = `absolute top-0 transform -translate-x-1/2 step-indicator transition-all duration-300 shadow-md 
                                        w-5 h-5 rounded-full flex items-center justify-center text-white text-[10px] font-bold 
                                        ${stepColorClass}
                                        group cursor-help hover:scale-125`;
                
                // Add tooltip
                indicator.innerHTML = `
                    ${stepLabel}
                    <span class="absolute top-full mt-1 px-2 py-0.5 bg-gray-800 text-white text-xs rounded opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap z-50">
                        ${tooltipText}
                    </span>
                `;
                
                // Set position.
                indicator.style.left = `${centerX}px`; 
                
                track.appendChild(indicator);
            }
        }


        function drawKeyboard() {
            const svg = document.getElementById('piano-keyboard-svg');
            const highlightedMidiNotes = state.highlightedMidiNotes; 
            
            svg.setAttribute('width', `${KEYBOARD_CONFIG.KEYBOARD_WIDTH}px`);
            svg.setAttribute('viewBox', `0 0 ${KEYBOARD_CONFIG.KEYBOARD_WIDTH} ${KEYBOARD_CONFIG.KEYBOARD_HEIGHT}`);
            svg.innerHTML = ''; 

            const WKW = KEYBOARD_CONFIG.WHITE_KEY_WIDTH;
            const BKW = KEYBOARD_CONFIG.BLACK_KEY_WIDTH;
            const WKH = KEYBOARD_CONFIG.WHITE_KEY_HEIGHT;
            const Y_START = KEYBOARD_CONFIG.KEY_Y_START;
            
            // 1. Draw White Keys first
            PIANO_KEY_DATA.forEach(key => {
                if (key.isWhite) {
                    const isHighlighted = highlightedMidiNotes.includes(key.midi); 
                    const x = getKeyXPosition(key.midi); 

                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute('x', x);
                    rect.setAttribute('y', Y_START);
                    rect.setAttribute('width', WKW);
                    rect.setAttribute('height', WKH);
                    rect.setAttribute('rx', 4); 
                    rect.setAttribute('ry', 4);
                    rect.setAttribute('stroke', '#a1a1ae');
                    rect.setAttribute('stroke-width', '1');
                    rect.setAttribute('fill', isHighlighted ? KEY_COLORS.HIGHLIGHT_WHITE : KEY_COLORS.WHITE);
                    rect.classList.add('highlight-transition'); 
                    
                    svg.appendChild(rect);

                    // --- Labeling Logic for White Keys ---
                    let labelText = null;
                    let labelFill = isHighlighted ? KEY_COLORS.WHITE : '#4b5563'; 

                    if (isHighlighted) {
                         labelText = key.name;
                    } else if (key.name === 'C' || key.name === 'F') {
                        labelText = `${key.name}${Math.floor(key.midi / 12) - 1}`;
                    }

                    if (labelText) {
                        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        text.setAttribute('x', x + WKW / 2);
                        text.setAttribute('y', Y_START + WKH - 10);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('font-size', '14');
                        text.setAttribute('font-weight', '600');
                        text.setAttribute('fill', labelFill);
                        text.textContent = labelText;
                        svg.appendChild(text);
                    }
                }
            });

            // 2. Draw Black Keys second (to place them on top)
            PIANO_KEY_DATA.forEach(key => {
                if (!key.isWhite) {
                    const isHighlighted = highlightedMidiNotes.includes(key.midi);
                    
                    const x = getKeyXPosition(key.midi); 

                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute('x', x);
                    rect.setAttribute('y', Y_START);
                    rect.setAttribute('width', BKW);
                    rect.setAttribute('height', KEYBOARD_CONFIG.BLACK_KEY_HEIGHT);
                    rect.setAttribute('rx', 3); 
                    rect.setAttribute('ry', 3);
                    rect.setAttribute('stroke', '#000000');
                    rect.setAttribute('stroke-width', '1');
                    rect.setAttribute('fill', isHighlighted ? KEY_COLORS.HIGHLIGHT_BLACK : KEY_COLORS.BLACK);
                    rect.classList.add('highlight-transition'); 

                    svg.appendChild(rect);
                    
                    // Black Key Labeling: Shows name if highlighted 
                    if (isHighlighted) {
                        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        text.setAttribute('x', x + BKW / 2);
                        text.setAttribute('y', Y_START + KEYBOARD_CONFIG.BLACK_KEY_HEIGHT - 10);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('font-size', '14');
                        text.setAttribute('font-weight', '600');
                        text.setAttribute('fill', KEY_COLORS.WHITE);
                        text.textContent = key.name;
                        svg.appendChild(text);
                    }
                }
            });
            
            const pianoContainer = document.getElementById('piano-container');
            
            // --- CONDITIONAL SCROLLING LOGIC ---
            if (state.isCenteringEnabled && state.highlightedMidiNotes.length > 0) {
                // Centering mode: scroll to center the lowest note of the chord/scale degree
                const centerMidi = state.highlightedMidiNotes[0]; 
                
                let centerScrollX = 0;
                const centerKeyData = PIANO_KEY_DATA.find(k => k.midi === centerMidi);
                
                if (centerKeyData) {
                    const WKW = KEYBOARD_CONFIG.WHITE_KEY_WIDTH;
                    const BKW = KEYBOARD_CONFIG.BLACK_KEY_WIDTH;
                    const centerKeyX = getKeyXPosition(centerKeyData.midi);
                    const containerWidth = pianoContainer.offsetWidth;
                    
                    const keyWidth = centerKeyData.isWhite ? WKW : BKW;
                    centerScrollX = centerKeyX - (containerWidth / 2) + (keyWidth / 2);

                    centerScrollX = Math.max(0, centerScrollX);
                    centerScrollX = Math.min(KEYBOARD_CONFIG.KEYBOARD_WIDTH - containerWidth, centerScrollX);
                }
                
                requestAnimationFrame(() => {
                    // Smoothly scroll to the center position
                    pianoContainer.scroll({ left: centerScrollX, behavior: 'smooth' });
                });
            } else {
                // Fixed scroll mode: scroll to the far left (C4)
                requestAnimationFrame(() => {
                    pianoContainer.scrollLeft = 0;
                });
            }
        }
        
        function renderKeySelect() {
            const select = document.getElementById('key-select');
            select.innerHTML = KEYS.map((key, index) => 
                `<option value="${index}" ${index === state.currentKeyIndex ? 'selected' : ''}>${key}</option>`
            ).join('');
        }
        
        /**
         * Renders all scale modes, filtering out pentatonic for Chord View.
         */
        function renderModeSelect() {
            const select = document.getElementById('mode-select');
            
            const allModes = Object.entries(SCALE_MODES);
            let modesToRender = allModes;

            if (state.visualizationMode === 'chord') {
                // Filter: Only allow 7-note diatonic scales in Chord View
                modesToRender = allModes.filter(([id, mode]) => 
                    mode.isDiatonic && mode.intervals.length === 7
                );
                
                // If the current mode is a filtered-out one (like pentatonic), reset to 'major'
                const currentModeExists = modesToRender.some(([id]) => id === state.currentModeId);
                if (!currentModeExists) {
                     state.currentModeId = 'major';
                     state.currentDegree = 1; // Reset degree as well since pentatonic has only 5
                }
            }
            // If we are in 'scale' view, modesToRender is the full list.
            
            select.innerHTML = modesToRender.map(([id, mode]) => 
                `<option value="${id}" ${id === state.currentModeId ? 'selected' : ''}>${mode.name}</option>`
            ).join('');
        }
        
        function renderVisualizationModeButtons() {
            const container = document.getElementById('mode-toggle-container');
            const isChord = state.visualizationMode === 'chord';

            container.innerHTML = `
                <button id="mode-chord-btn" onclick="handleVisualizationModeChange('chord')"
                        class="segmented-btn py-2.5 px-3 w-1/2 text-sm md:text-base ${isChord ? 'active' : 'bg-white text-gray-700 hover:bg-gray-50'}">
                    Chord View
                </button>
                <button id="mode-scale-btn" onclick="handleVisualizationModeChange('scale')"
                        class="segmented-btn py-2.5 px-3 w-1/2 text-sm md:text-base ${!isChord ? 'active' : 'bg-white text-gray-700 hover:bg-gray-50'}">
                    Scale View
                </button>
            `;
        }

        function renderChordButtons() {
            const container = document.getElementById('chord-buttons-container');
            const mode = getCurrentMode();
            const qualities = mode.qualities;
            const triadQualities = mode.triadQualities;
            
            const numDegrees = mode.degrees; // Now 8 for diatonic scales
            const isScaleView = state.visualizationMode === 'scale';
            
            // Inversions are only possible for 7-note diatonic scales in Chord View, AND not for the 8th degree
            const canInvert = mode.isDiatonic && mode.intervals.length === 7 && state.visualizationMode === 'chord' && state.currentDegree !== 8;


            // Use grid-cols-8 for 8 degrees when on large screens
            container.classList.remove('sm:grid-cols-7', 'sm:grid-cols-5');
            container.classList.add(numDegrees === 8 ? 'sm:grid-cols-8' : 'sm:grid-cols-5');


            container.innerHTML = mode.qualities.slice(0, numDegrees).map((romanNumeral, index) => {
                const degree = index + 1;
                const isActive = degree === state.currentDegree;
                
                // Use the direct index (0-7) for lookup
                const qualityIndex = index; 

                let inversionSuffix = '';
                let qualityDisplay = '';
                let mainButtonText = '';
                let secondaryButtonText = '';
                
                if (isScaleView) {
                    // SCALE VIEW: Use simple Arabic numeral (1, 2, 3...)
                    mainButtonText = degree.toString(); 
                } else {
                    // CHORD VIEW: Use Roman numeral and chord quality/inversion
                    mainButtonText = romanNumeral;
                    // Only show quality for 7-note diatonic scales in Chord View
                    qualityDisplay = mode.isDiatonic && mode.intervals.length === 7 ? triadQualities[qualityIndex] : '';
                    
                    // Show inversion suffix only if on degrees 1-7
                    if (isActive && degree <= 7 && canInvert && state.currentInversion > 0) {
                         inversionSuffix = state.currentInversion === 1 ? ' / 6' : ' / 6/4';
                    }
                    secondaryButtonText = `${qualityDisplay}${inversionSuffix}`;
                }


                return `
                    <button onclick="handleDegreeChange(${degree})"
                            class="py-3 px-2 rounded-lg font-extrabold transition duration-200 shadow-lg 
                            flex flex-col items-center justify-center min-h-20
                            ${isActive 
                                ? 'bg-blue-700 text-white ring-4 ring-blue-300 transform scale-105' 
                                : 'bg-gray-100 text-gray-700 hover:bg-gray-300'
                            }">
                        <span class="text-xl">${mainButtonText}</span>
                        <span class="text-xs font-medium opacity-80">${secondaryButtonText}</span>
                    </button>
                `;
            }).join('');
        }

        function renderChordName() {
            document.getElementById('current-chord-display').textContent = getHighlightName();
        }
        
        // --- HANDLERS ---
        
        function updateUI() {
            // Check if the currently selected mode is still valid for the current visualization mode. 
            // This is handled in renderModeSelect now, which can change state.currentModeId.
            renderModeSelect(); 

            const mode = getCurrentMode();
            
            // If we move to a scale with fewer degrees (e.g., from Major to Pentatonic)
            if (state.currentDegree > mode.degrees) {
                state.currentDegree = 1;
            }
            
            // Inversions are only possible for 7-note diatonic scales in Chord View, AND not for the 8th degree
            const canInvert = mode.isDiatonic && mode.intervals.length === 7 && state.visualizationMode === 'chord' && state.currentDegree !== 8;
            
            if (!canInvert) {
                state.currentInversion = 0;
            }

            if (state.visualizationMode === 'chord') {
                state.highlightedMidiNotes = calculateChordMidiNotes(
                    state.currentKeyIndex, 
                    state.currentDegree,
                    state.currentInversion 
                );
            } else { // 'scale' mode
                state.highlightedMidiNotes = calculateSingleScaleMidiNote(
                    state.currentKeyIndex, 
                    state.currentDegree
                );
            }
            
            state.highlightedPitchClasses = state.highlightedMidiNotes.map(midi => midi % 12);
            
            renderKeySelect();
            // renderModeSelect() is called first in updateUI()
            renderChordButtons();
            renderChordName(); 
            renderStepVisualizer(); 
            renderVisualizationModeButtons(); 
            drawKeyboard(); 
        }

        function handleKeyChange(keyIndex) {
            state.currentKeyIndex = parseInt(keyIndex);
            state.currentDegree = 1; 
            state.currentInversion = 0; 
            updateUI();
        }

        function handleModeChange(modeId) {
            state.currentModeId = modeId;
            state.currentDegree = 1; 
            state.currentInversion = 0; 
            updateUI();
        }
        
        function handleDegreeChange(degree) {
            const mode = getCurrentMode();
            
            // Inversions are only possible for 7-note diatonic scales in Chord View, AND not for the 8th degree
            const canInvert = mode.isDiatonic && mode.intervals.length === 7 && state.visualizationMode === 'chord' && degree !== 8;

            if (degree === state.currentDegree) {
                if (canInvert) {
                    // Cycle the inversion: 0 (Root) -> 1 (1st) -> 2 (2nd) -> 0 (Root)
                    state.currentInversion = (state.currentInversion + 1) % 3; 
                } else {
                    state.currentInversion = 0;
                }
            } else {
                state.currentDegree = degree;
                state.currentInversion = 0; 
            }
            updateUI();
        }

        function handleVisualizationModeChange(mode) {
            state.visualizationMode = mode;
            state.currentInversion = 0; 
            updateUI();
        }
        
        function toggleCentering(checked) {
            state.isCenteringEnabled = checked;
            drawKeyboard();
        }

        // --- PWA Registration (Existing functionality) ---
        function registerPwa() {
            const manifestContent = {
                "name": "TheoryViz",
                "short_name": "TheoryViz",
                "start_url": ".",
                "display": "standalone",
                "background_color": "#ffffff",
                "theme_color": "#3b82f6",
                "icons": [
                    {"src": "https://placehold.co/192x192/3b82f6/ffffff?text=TV", "sizes": "192x192", "type": "image/png"},
                    {"src": "https://placehold.co/512x512/3b82f6/ffffff?text=TV", "sizes": "512x512", "type": "image/png"}
                ]
            };

            const manifestBlob = new Blob([JSON.stringify(manifestContent)], {type : 'application/json'});
            const manifestUrl = URL.createObjectURL(manifestBlob);
            
            const link = document.createElement('link');
            link.rel = 'manifest';
            link.href = manifestUrl;
            document.head.appendChild(link);
        }
        // --- APPLICATION STARTUP ---
        
        window.onload = () => {
             // Re-initialize PIANO_KEY_DATA
             PIANO_KEY_DATA.length = 0;
             for (let i = START_MIDI; i <= END_MIDI; i++) {
                 PIANO_KEY_DATA.push({
                     midi: i,
                     pitchClass: i % 12,
                     name: KEYS[i % 12],
                     isWhite: MAJOR_INTERVALS.includes(i % 12),
                 });
             }
             updateUI();
             registerPwa();
        };

        window.addEventListener('resize', updateUI); 
        
    </script>
</body>
</html>
